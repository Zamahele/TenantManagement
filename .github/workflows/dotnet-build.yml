name: PropertyManagement Build .NET 8

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --no-restore --configuration Release

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: .

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: build-output

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Test with coverage
        run: dotnet test --no-build --configuration Release --collect:"XPlat Code Coverage"

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./PropertyManagement.Test/TestResults/**/*.cobertura.xml
          token: ${{ secrets.CODECOV_TOKEN }}

  publish:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: build-output

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Publish
        run: dotnet publish --configuration Release --output ./publish

      - name: Copy Dockerfile to publish output
        run: cp PropertyManagement.Web/Dockerfile ./publish/

      - name: Copy certificate to root (with docker-compose.yml)
        run: cp PropertyManagement.Web/https/aspnetapp.pfx ./aspnetapp.pfx

      - name: Upload published artifact
        uses: actions/upload-artifact@v4
        with:
          name: published-app
          path: ./publish

      - name: Upload docker-compose and cert
        uses: actions/upload-artifact@v4
        with:
          name: docker-compose
          path: |
            docker-compose.yml
            aspnetapp.pfx

  ftp-deploy:
    runs-on: ubuntu-latest
    needs: publish
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - name: Download published artifact
        uses: actions/download-artifact@v4
        with:
          name: published-app
          path: ./publish

      - name: Prepare deployment files
        run: |
          sed -i 's/#{DB_SERVER}#/${{ secrets.DB_SERVER }}/g' ./publish/appsettings.Production.json
          sed -i 's/#{DB_USERNAME}#/${{ secrets.DB_USERNAME }}/g' ./publish/appsettings.Production.json
          sed -i 's/#{DB_PASSWORD}#/${{ secrets.DB_PASSWORD }}/g' ./publish/appsettings.Production.json
          
          mkdir -p ./publish/../logs
          
          cat > ./publish/setup-logs.ps1 << 'EOF'
          $logDir = "/gcweproperty.co.za/logs"
          if (-not (Test-Path $logDir)) {
              try {
                  New-Item -ItemType Directory -Path $logDir -Force
                  Write-Host "Created logs directory: $logDir"
              } catch {
                  Write-Host "Could not create preferred log directory, using fallback"
              }
          } else {
              Write-Host "Logs directory already exists: $logDir"
          }
          EOF
          
          echo "Database credentials configured in appsettings.Production.json"
          echo "Log directory setup script created"

      - name: Deploy to FTP server
        uses: SamKirkland/FTP-Deploy-Action@v4.3.5
        with:
          server: ${{ secrets.FTP_SERVER }}
          username: ${{ secrets.FTP_USERNAME }}
          password: ${{ secrets.FTP_PASSWORD }}
          local-dir: ./publish/
          server-dir: /gcweproperty.co.za/wwwroot/
          dangerous-clean-slate: false
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
            Dockerfile

      - name: Wait for application to start
        run: |
          echo "Waiting for application to start up..."
          sleep 30
          
          for i in {1..10}; do
            if curl -f -s "http://${{ secrets.FTP_SERVER }}/gcweproperty.co.za/health" > /dev/null 2>&1; then
              echo "Application is responding"
              break
            elif curl -f -s "https://${{ secrets.FTP_SERVER }}/gcweproperty.co.za/health" > /dev/null 2>&1; then
              echo "Application is responding (HTTPS)"
              break
            else
              echo "Waiting for application... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: Apply migrations automatically via HTTP
        run: |
          echo "Triggering automatic database migration..."
          
          HTTP_URL="http://${{ secrets.FTP_SERVER }}/gcweproperty.co.za/api/migration/apply"
          HTTPS_URL="https://${{ secrets.FTP_SERVER }}/gcweproperty.co.za/api/migration/apply"
          
          AUTH_TOKEN="${{ secrets.FTP_PASSWORD }}"
          
          for URL in "$HTTPS_URL" "$HTTP_URL"; do
            echo "Trying migration endpoint: $URL"
            
            RESPONSE=$(curl -s -w "\n%{http_code}" \
              -X POST \
              -H "Content-Type: application/json" \
              -H "authToken: $AUTH_TOKEN" \
              "$URL" 2>/dev/null)
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Migration completed successfully!"
              echo "Response: $BODY"
              
              if echo "$BODY" | grep -q '"success":true'; then
                echo "Database migrations applied successfully via HTTP endpoint!"
                exit 0
              fi
              break
            elif [ "$HTTP_CODE" = "401" ]; then
              echo "Unauthorized - check auth token configuration"
              break
            elif [ "$HTTP_CODE" = "500" ]; then
              echo "Server error during migration:"
              echo "$BODY"
              break
            else
              echo "Endpoint not ready (HTTP $HTTP_CODE), trying next URL..."
            fi
          done
          
          echo "Automatic migration via HTTP failed or not available"
          echo "Migration may need to be triggered manually or application may not be fully started yet"

      - name: Check migration status
        run: |
          echo "Checking final migration status..."
          
          for URL in "https://${{ secrets.FTP_SERVER }}/gcweproperty.co.za/api/migration/status" "http://${{ secrets.FTP_SERVER }}/gcweproperty.co.za/api/migration/status"; do
            RESPONSE=$(curl -s -w "\n%{http_code}" "$URL" 2>/dev/null)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Migration status retrieved:"
              echo "$BODY"
              
              if echo "$BODY" | grep -q '"isUpToDate":true'; then
                echo "Database is up to date!"
              elif echo "$BODY" | grep -q '"pendingMigrations":[^0]'; then
                echo "There are still pending migrations that may need manual attention"
              fi
              break
            fi
          done

      - name: Deployment Summary
        run: |
          echo ""
          echo "FULLY AUTOMATED DEPLOYMENT COMPLETED!"
          echo ""
          echo "What was accomplished:"
          echo "- Application built and tested"
          echo "- Database credentials configured securely"
          echo "- Log directory structure prepared"
          echo "- Files uploaded to FTP server"
          echo "- Automatic migration attempted via HTTP endpoint"
          echo "- Migration status verified"
          echo ""
          echo "Your application is available at:"
          echo "- http://${{ secrets.FTP_SERVER }}/gcweproperty.co.za/"
          echo "- https://${{ secrets.FTP_SERVER }}/gcweproperty.co.za/ (if HTTPS configured)"
          echo ""
          echo "Application structure on server:"
          echo "- Application: /gcweproperty.co.za/wwwroot/"
          echo "- Logs: /gcweproperty.co.za/logs/"
          echo "- Setup script: /gcweproperty.co.za/wwwroot/setup-logs.ps1"
          echo ""
          echo "Monitoring endpoints:"
          echo "- Health: /health"
          echo "- Migration Status: /api/migration/status"
          echo "- Metrics: /metrics"
          echo ""
          echo "Log files:"
          echo "- Application: /gcweproperty.co.za/logs/propertymanagement.log"
          echo "- Daily rotation: propertymanagement-YYYY-MM-DD.log"
          echo ""
          echo "Manual migration (if needed):"
          echo "POST /api/migration/apply"
          echo "Header: authToken: [your-ftp-password]"
          echo ""
          echo "Zero-touch deployment complete!"

  docker-build-and-push:
    runs-on: ubuntu-latest
    needs: publish
    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Build Docker image
        run: |
          docker build -f PropertyManagement.Web/Dockerfile -t ghcr.io/zamahele/tenantmanagement:${{ github.sha }} .

      - name: Push Docker image
        run: |
          docker push ghcr.io/zamahele/tenantmanagement:${{ github.sha }}

      - name: Tag image as latest
        run: docker tag ghcr.io/zamahele/tenantmanagement:${{ github.sha }} ghcr.io/zamahele/tenantmanagement:latest

      - name: Push latest tag
        run: docker push ghcr.io/zamahele/tenantmanagement:latest
